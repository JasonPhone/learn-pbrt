---
title: "2 几何和变换"
author: "ja50n"
date: "2022-08-23"
---

几何指的是基础几何，即光追模型里的点、向量、光线等等，而不是图形绘制的场景几何。

# 1 坐标系

在一个原点和一组（不相关的）向量基底下，使用一组标量可以唯一表示一个点。为了避免无穷的相对依赖，使用原点 $(0, 0, 0)$ 和基底 $(1, 0, 0)$、$(0, 1, 0)$ 和 $(0, 0, 1)$ 作为绝对的世界空间，其他坐标 frame 都直接或间接基于它。

## 1.1 手性

左右手性的选择是任意的，但是确定后的许多几何操作都隐式依赖于它。pbrt 使用左手系。

# 2 向量

pbrt 提供二维和三维向量，使用模板实现。

实现代码里的 `#ifndef NDEBUG` 是在调试状态下启用自定义的带 assert 的拷贝和复制重载，其他情况下直接使用自动生成的对应函数。

向量要实现的功能主要是运算、相等判断和模长，另外有重载下标符号来实现取分量的拷贝或者引用（便于循环遍历）、重载输出流等等。注意在必要的时候（所有运算）检查 NaN。

可以用模板来指定维数，但是访问的时候就没法用直观的字母来表示。

另外可以从模板定义几个常用的确定类型，比如 `using Vector2d = Vector2<double>`。

可见性上，使用 private 没有什么收益，还会增加访问的代码量，所以全部暴露出来就好。

项目的 assertion 机制需要注意。

基于单个向量构造局部坐标系有多种策略。pbrt 假设传入的向量已经归一化，然后通过

1. 抹去 x 和 y 轴上较小的分量
2. 交换剩余的两个分量并将其中一个变号
3. 归一化

来构造第二个分量。第三个分量为之前两个的叉积。

叉积是被限定在坐标系里的，因此不能看出坐标系的手性。

# 3 点

点的结构和实现都类似于向量，但实际的意义不同。

需要提供一些特殊的转换，例如从浮点到整数、从向量到点或从点到向量。这些转换都应该用 `explicit` 指明。

由于是两个不同的类型，数学上可以互操作的特性也要一一实现，比如将一个点沿一个向量平移、点点相减得向量等。

> 点和向量的数据都用一个独立类型代替如何，比如矩阵？由这个组合进去的类型负责实现通用的底层运算，再用“向量”、“点”这些概念去控制它们专属的运算。尽管还是要挨个实现重载，但运算细节只需要实现一次。

一些点独有的运算，比如两点的构成的 AABB 中取最小/最大顶点、上下取整、取绝对值等等。

# 4 法向量

法向量也是向量，但其附属于特定的平面，在“某些场合下”行为与向量不同，比如对线性变换的反应、不能与点相加、不能叉积等等。注意法向量不一定是归一化的。

法向量和普通三维向量的互相转换，由于不是常规操作，需要用 `explicit` 指明，避免允许赋值行为。

不能叉积，但是要支持点积运算，又多一点代码。

法向量比较特殊的一个操作，是反转方向。这个经常被用来保证法向量总是顺着光线方向，而另外记录法向量和它附属平面的关系。

# 5 光线

光线的模型是射线，由原点加方向确定。

除了这两个成员，光线类还需要记录自身产生的时间 `time` 和最大生命期 `tMax`，后者限制了光线的传播距离，常被用来在相交测试中记录光线的击中时间，因此是一个 `mutable` 类型。此外，光线还会记录它源点所在的介质，以便正常处理跨介质的传播行为。

<!-- TODO 此处的介质指针类型需要考虑一下，是直接指针还是智能指针。 -->

重载了括号运算符，从时间获取光线（粒子的）位置会简洁一点。

## 5.1 光线微分

为了实现材质的抗锯齿，我们需要记录光线的其他信息，来估计场景的一个面元投影到纹理上覆盖的区域。

光线微分（微元？）记录了两条辅助光线的信息，这两条光线是主光线在相机视角分别在 x 和 y 方向偏移一个样本得到的两个采样。纹理类通过计算这三条光线投影在待着色物体上的面积，可以估计出抗锯齿需要涉及的纹理区域。

光线微分类继承自光线，需要额外记录光线是否有微分、主光线的采样坐标和（在成像平面上的？）单位方向，后两者由相机类负责计算。

# 6 包围盒

接下来，轴对齐很有用。

例如，pbrt 目前的多线程加速是将胶片划分成若干个矩形各自处理，而 BVH 使用长方体来包围几何图元，实现快速的相交测试。更低维的是区间，在数学运算里常用；而更高维的目前用不上。因此我们需要实现二维和三维包围的模板类。这两个模板类用来描述区间的大小，以及一些类似集合的运算。

一般常用 AABB　来记录一个包围盒/区域，也可以用 Oriented Bounding Box，两者都是长方体，但是 OBB 不要求边和坐标轴平行，可以更紧致地包围图元，但是构造和实现起来比较麻烦。描述一个 AABB 可以使用一个顶点 + 三边长度，或者两个对角点，都是差不多的。如果使用对角点描述 AABB，为了保证取向，一般用 AABB 上“最大”和“最小”的两个点，即三个分量区间上的最小值和最大值分别构成的两个点。

除了几个构造函数，另外可以实现的功能有

- 重载下标
- 获取指定顶点
- 包围盒取并和取交
- 包围盒新增一个点位的取并（扩大包围盒直到覆盖新点）
- 包围盒之间的覆盖测试
- 包围盒和点的包含测试（开或闭区间）
- 将包围盒在所有轴上扩张指定范围（用于特别小/薄的包围盒）
- 获取对角向量（从最小点指向最大点，即长宽高）
- 包围盒表面积和体积（？哪里常用了）
- 获取范围最大的分量（可以用于确定沿哪个轴划分构建加速结构）
- 沿主对角线（最大点减最小点）插值，即在主对角线上取点
- 获取指定点相对于包围盒的归一化偏移量，与最小点重合是 $(0, 0, 0)$，与最大点重合是 $(1, 1, 1)$
- 从（三维）包围盒构造包围球，显然应该是包围包围盒的球
- 遍历（二维整型）包围盒内的各点，左闭右开

~~这书有点像文档啊~~

# 7 变换

广义上的变换是从一个向量（或者点）到另一个向量（或者点）的映射。它可以是任何一种过程，但是我们只取一部分拥有以下特性的子集：

- 线性，即 $T(s\vec{v}) = sT(\vec{v})$ 且 $T(\vec{v}_1 + \vec{v}_2) = T(\vec{v}_1) + T(\vec{v}_2)$，其中 $s$ 是标量，$\vec{v}$ 是向量。
- 连续性，（同胚？），变换前“相邻”的点变换后依然“相邻”。
- 一一映射且可逆

对于三维坐标系下的点、向量和法向量，四阶方阵可以表示出所有*坐标系之间的线性变换*和*固定坐标系下的线性变换*，因此，一个四阶方阵有两种解释方式：

1. 固定坐标 frame（译作框架？）下的变换：变换矩阵用于描述对象在相同 frame 下的新位置
2. 变换一个 frame：变换矩阵也可以描述对象在新的 frame 下的坐标（以相对于原 frame 的形式）

多数情况下我们使用变换矩阵获取一个对象（比如法向量）相对于一个 frame（比如 TBN 坐标系）在另一个 frame（比如世界坐标系）下的新坐标，或者更常见的是 MVP 变换和相机的 canonical 坐标空间。

## 7.1 齐次坐标

一个 frame 下，如果只是用三个量来记录对象，就无法区分点和向量，而两者在许多变换下的行为是不同的。如果将 frame 用一个原点 $p_o$ 和三个基底 $\vec{v}_1$、$\vec{v}_2$、$\vec{v}_3$ 表示，那么点可以表示为原点加上三个基底上的偏移，而向量就只是坐标分别与三个基底相乘，即点是 $(x, y, z, 1)(\vec{v}_1, \vec{v}_2, \vec{v}_3, p_o)^T$，而向量是 $(x, y, z, 1)(\vec{v}_1, \vec{v}_2, \vec{v}_3, p_o)^T$（有点取巧的解释）。这样的表示方式就是齐次坐标。第四个分量有时被称为权重，对于点来说可以是除了 0 之外的任何数，只要前三个分量做了对应的缩放。

对应地，变换矩阵 $M$ 是四阶方阵，四个列向量分别为 $M_x$、$M_y$、$M_z$ 和 $M_p$，对应三个基底和一个原点是如何变换的。

通过描述基的变换，我们就可以知道任何相对于这个基的点或向量是如何变换的。因为当前坐标系下的点和向量是以当前的 frame 描述的，所以，对它们（点和向量）直接应用变换相当于对当前坐标系的基应用变换，然后找到点和向量相对于变换后的基的坐标。

代码中不会直接使用或抽象齐次坐标，而是在变换时先隐式地将点和向量坐标转换成齐次形式，完成变换后再转换回普通坐标。因此，我们把“变换”本身抽象为一个类。

一个变换可以用一个四阶方阵表示（另外实现并组合进变换类中），连带存储了逆矩阵等其他数据。（见后文）

性能角度，如果一个场景拥有很多物体但是只有较少的变换操作，每变换一个物体都重新创建相同的变换是很浪费的，因此物体基类存储了一个变换指针，另外使用了一个缓存类来保证相同的变换只存在一个实例。这样做的问题是：变换矩阵不能轻易改变。实践上这不会有非常大的问题，因为场景在渲染时没有改变变换的需求。

## 7.2 基础操作

`Transform` 默认是一个单位矩阵。也可以从一个 4x4 的二维数组或矩阵获取，注意求逆。

逆变换可以通过交换两个矩阵获得。

<!-- TODO 转置功能也有用？ -->

可以发现，4x4 矩阵的前三列是新 frame 的三个基底在原 frame 中的坐标，第四列是新 frame 的原点在原 frame 中的坐标。

## 7.3 平移变换

原坐标分别加上固定偏移量，由变换矩阵第四列的前三个量确定。

## 7.4 缩放

原坐标分别乘以固定量，由变换矩阵主对角线的前三个量确定。

## 7.5 绕坐标轴旋转

分别绕三轴（逆着轴的正方向看去，顺时针）旋转，形式是指定旋转轴的缩放系数为 1，然后在另外两轴填入二维旋转矩阵。注意绕 Y 轴旋转时，由于顺时针方向和坐标轴次序不同，需要用二位旋转的逆矩阵（或者说转置矩阵？）。

在右手系中，以上旋转矩阵的效果都是逆时针。这可以作为区分左右手系的标志。

## 7.6 绕任意坐标轴旋转

将向量 $\vec{v}$ 绕任意轴 $\vec{a}$ 旋转，有两种实现方式。

一种是先把任意轴变换到某个坐标轴的位置（既平行也过同一点），然后使用上一小节的绕坐标轴旋转，然后再整体变换回原始轴的位置。

更优雅的一种做法是构建一个局部的坐标系，在此坐标系中构建好旋转矩阵，再应用到世界坐标系上。局部坐标系的一个坐标轴应该是旋转轴，其他两个坐标轴应该在*与旋转轴垂直*且*过被旋转点或向量终点（端点即可）*的平面里，后一个要求是省去计算点在平面的投影或向量与平面的交点。

因此，我们需要计算向量 $\vec{v}_1$ 和 $\vec{v}_2$，以便和 $\vec{a}$ 构成一组基底。

首先，通过 $\vec{v}$ 在 $\vec{a}$ 方向上的投影向量，构造一个以 $\vec{v}$ 为直角边的三角形，另一个直角边就可以作为 $\vec{v}_1$。$\vec{v}_2$ 就是 $\vec{v}_1$ 和 $\vec{a}$ 叉积（注意手性）。

另外，书上这部分的推导是按照面向 $\vec{a}$ 正方向、逆时针旋转 $\theta$ 度推导的，如果要统一成顺时针，应该把最后一个公式 $\vec{v}' = \vec{v}_c + \vec{v}_1\cos\theta + \vec{v}_2\cos\theta$ 的弧度全部加上负号。

## 7.7 视线方向变换

Look-At 变换对放置相机很有用。给定相机的位置、观察点和上方向，就可以确定唯一的相机空间坐标。注意手性。

相机空间的坐标系当然可以用一个 4x4 方阵描述。

# 8 应用变换

讨论将变换矩阵应用到之前各种对象上时需要注意的问题。

一般直接代入公式，而不是真的使用矩阵的乘法。

## 8.1 点

隐式地将普通坐标转换为齐次坐标，直接乘上，然后注意除以 $w$ 分量。

## 8.2 向量

向量地齐次坐标 $w$ 分量是 0，可以直接计算前三个分量并返回。

## 8.3 法向量

这个是需要注意的，切向量 $\vec{t}$ 在直接变换后仍然能保持与新的切点相切，但是法向量 $\vec{n}$ 与切向量的垂直关系在线性变换下并不保持。我们需要对 $\vec{n}$ 应用另一个线性变换 $S$ 使得 $(S\vec{n})\cdot (M\vec{t}) = 0$，即

$$
\begin{split}
0 &= (S\vec{n})^T(M\vec{t})\\
  &= \vec{n}^TS^TM\vec{t}
\end{split}
$$

而原来的法向量与切向量垂直有

$$
\vec{n}\cdot \vec{t} = \vec{n}^T\vec{t} = 0
$$

则要求 $S^TM = I$，即 $S^T$ 是 $M$ 的逆矩阵。这是在 `Transform` 类中存储逆矩阵的一个主要原因。

## 8.4 光线

对光线进行变换，就是把源点和方向做变换，其他信息不变。对光线微分的变换也类似。

<!-- TODO 这里有一个浮点误差的修正，需要再看一下，或者到 3.9.4 再看。 -->

## 8.5 包围盒

最简单的方法是把包围盒的顶点全部变换，然后依据变换后的顶点构造新的包围盒。可以使用包围盒的并操作把新的顶点不断包含进来，也可以用更高效的方法。

## 8.6 组合变换

就是矩阵乘法。

## 8.7 手性

一些变换会改变坐标系的手性，而例如法向量总是指向“外侧”等特性在手性变换时也要跟着翻转方向。

变换矩阵左上角的三阶方阵，即新 frame 的三个基组成的矩阵，当它的行列式为负数时，应用变换后的坐标系手性会发生变化（体积的负缩放）。

<!-- TODO 1.8.9 及之后内容跳过 -->