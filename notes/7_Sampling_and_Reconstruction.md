---
title: "7 采样和重建"
author: "ja50n"
date: "2022-09-14"
---

像素是离散的，但是 incident radiance 是连续的，这就涉及到如何使用离散的像素点来比较好地表示连续的颜色，即从连续函数上离散采样，并使采样点能够比较好地反映（重建）原函数的问题。

本章涉及的内容有采样理论、低差异序列。实现的类有 `Sampler` 及其子类、混合多个采样的 `Filter` 和将采样累积到像素上的 `Film`。

# 1 采样理论

图像的像素和显示器的像素不是同一个概念。将入射的 radiance 视作与图像长宽相关的连续函数，图像像素代表一个特定位置的离散采样值，而显示器像素是一个物理的发光单元。显示器基于图像像素，利用自己的显示像素*重建*一个连续的图像函数，旨在与原始的 radiance 尽可能接近。

<!-- 要获得图像的离散像素值，需要对原始的图像函数进行采样，而对于 ray tracer 来说，要获得图像函数，唯一的方式就是通过追踪光线进行采样。虽然只对像素对应的那一个方向采样就可以获得图像，更好的方式是对相关的若干个位置进行采样，然后将采样值混合到一个像素中。 -->

## 1.1 频域和傅里叶变换

频域图像代表各频率的（正弦）波对于原始函数的贡献。

傅里叶变换可以将函数分解为一系列正弦波。在频域下可以通过傅里叶分析来比较原函数和重建函数之间的误差，以便优化重建结果。

傅里叶变换

$$
F(\omega) = \int_{-\infty}^\infty f(x)\mathrm{e}^{-i2\pi\omega x}\mathrm{d}x
$$

傅里叶合成

$$
f(x) = \int_{-\infty}^\infty F(\omega)\mathrm{e}^{i2\pi\omega x}\mathrm{d}\omega
$$

显然傅里叶变换是一个线性运算符。

狄拉克 delta 分布：$\int\delta(x)\mathrm{d}x = 1$ 且 $\forall x \ne 0, \delta(x) = 0$，则一个函数与此函数的乘积的积分，等于这个函数在零点的取值。

## 1.2 理想的采样和重建

采样需要我们取一系列等距的采样点，数学上就是一系列以采样点处为“零点”的 delta 函数（shah 函数）。注意采样周期 $T$ 和“零点”值的关系。

$$
III_T(x) = T\sum_{i = -\infty}^\infty\delta(x - iT)
$$

用这个函数与原函数相乘就可以得到采样结果。

而要构造原函数 $f$ 的重建 $\tilde{f}$，则需要用采样结果与重建过滤函数 $r(x)$ 进行卷积。

$$
(IIIT(x)f(x))\otimes r(x)
$$

而卷积运算 $\otimes$ 定义为

$$
f(x)\otimes g(x) = \int_{-\infty}^\infty f(x')g(x - x')\mathrm{d}x'
$$

即卷积结果在一个点上的取值，等于函数 $f$ 在整个域上的取值乘上一个过滤函数 $g$ 再求积分（离散的话即求和），而 $g$ 的过滤策略取决于整个域上其他位置到待求值点的*有向*距离。

如此一来，重建结果 $\tilde{f}$ 就是

$$
\begin{split}
\tilde{f}(x) 
&= (III_T(x)f(x))\otimes r(x) \\[2ex]
&= \sum_{x'=-\infty}^\infty T\sum_{i = -\infty}^\infty\delta(x'-iT)f(iT)r(x - x') \qquad [展开]\\[2ex]
&= \sum_{x'=-\infty}^\infty Tf(iT)r(x - x')  \qquad [\forall x'\ne iT, \delta(x') = 0]\\[2ex]
&= T\sum_{i=-\infty}^\infty f(iT)r(x - iT) \qquad [离散取值]
\end{split}
$$

即，通过对离散值进行插值，可以获得重建函数。

然后看使用傅里叶分析的同样过程。在频域空间里进行分析，可以实现根据采样值完美重建原函数的效果。此处需要原函数在带宽上有限的假设，即 $\exist \omega_0: \forall |\omega| > \omega_0, F(\omega) = 0$。

另外一个重要的性质：两个函数之积的傅里叶变换，等于各自的傅里叶变换再卷积，即

$$
F\{f(x)g(x)\} = F(\omega)\otimes G(\omega)
$$

同时，两个函数卷积的傅里叶变换也与各自傅里叶变换后的乘积相等。

这两个基本上用微积分知识就可以证明。

然后，一个周期 $T$ 的 shah 函数经傅里叶变换后得到周期为 $\frac{1}{T}$ 的 shah 函数（证明[见此](https://www.thefouriertransform.com/pairs/shah.php)，看不太懂）。这个和一个现象对应：采样脉冲的周期越大，其低频成分就越多。

因此，原函数的在时域上的采样可以由原函数的傅里叶变换结果与新的 shah 函数卷积来表示。函数与一个 delta 函数卷积会生成一个函数复制（delta 函数在全域积分为 1），与一个 shah 函数卷积就会得到一系列间距等于周期的复制。如果能从这一系列频域函数复制中恢复出一份，就可以完美重建出原函数。

最朴素的恢复方法就是将卷积结果与一个 box 函数 $\Pi_T(x)$ 相乘，其中

$$
\Pi_T(x) = \begin{cases}
&\frac{1}{T} & |x| < \frac{T}{2}\\
&0 & otherwise
\end{cases}
$$

这个函数的图像是一个方波。得到的结果就是在频域上的重建：

$$
\tilde{F} = (F(\omega)\otimes III_{\frac{1}{T}}(\omega))\Pi_{\frac{1}{T}}(\omega)
$$

其中 $T$ 是采样频率。

最终，我们得到了一个目前看来很 nice 的结论：只需要知道（或假设）函数的带宽有限，就可以通过等距采样来保存原函数的所有信息。里面的坑后面再说。

相对应地，应用傅里叶逆变换，在时域上也可以有相同的操作：

$$
\begin{split}
\tilde{f} 
&= \mathcal{F}\{(F(\omega)\otimes III_{\frac{1}{T}}(\omega))\Pi_{\frac{1}{T}}(\omega)\} \\
&= \mathcal{F}\{F(\omega)\otimes III_{\frac{1}{T}}(\omega)\}\otimes \mathrm{sinc}_T(x)\\
&= (f(x)III_{T}(x))\otimes \mathrm{sinc}_T(x)\\
&= (f(x)III_{T}(x))\otimes \mathrm{sinc}(Tx)\\
&= \sum_{i = -\infty}^\infty \mathrm{sinc}(x - Ti)f(Ti)
\end{split}
$$

注意 box 函数的傅里叶变换结果为 sinc 函数，它在全域上的取值都不同，很难用于重建，而取部分值得重建效果就不会很好。例如在时域上使用 box 函数去对一个点附近的采样点求平均（极端一点就是线性插值），将结果作为这个点的原函数值，相当于在频域上乘一个 sinc 函数，不仅没有完整提取中间部分的频率，还把复制系列里面其他部分的高频信号给放了进来。

## 1.3 走样

除了 sinc 函数定义域的问题，实际应用中还会遇到的问题是原信号的带宽问题。带宽可能不是有限的，或者假设的带宽太低（导致采样频率也太低），都会导致重建结果不够好。

之前提到，如果能在频域上用 box 函数把正中间的傅里叶变换结果提取出来，就可以完成重建。如果采样频率太低，频域上的函数复制系列的间距也会变小，高频部分的信号就会溢出到我们要截取的 box 里面，造成走样。

解决走样的直接方法就是增大采样率，具体是增大到信号最高频率成分的两倍（奈氏准则）。而带宽无限的信号则无法被理想采样，因为频域上的复制成份总会相互覆盖。然而，CG 中的许多函数都是带宽无限的，比如包含不连续值的函数（不连续的地方永远不会被采样出来）。因此，除了增大采样率，我们还需要其他有效的方法。

## 1.4 反走样技术

走样可以被分为采样时出现的前走样和重建时出现的后走样。

### 非均匀采样

尽管点采样数学上不可能进行理想重建，我们还是可以通过使用间距不均匀的采样来优化重建时的视觉效果。

令 $\xi$ 为在 $0$ 和 $1$ 之间分布的一个随机数，一个不均匀采样的脉冲可以表示为

<!-- TODO 脉冲的取值可以永远是1吗？ -->
$$
\sum_{i = -\infty}^\infty \delta(x - (i + \frac{1}{2} - \xi) T)
$$

如果采样频率不够，无论均匀还是非均匀的采样都无法获取原函数的完整信息，但是非均匀采样的瑕疵没有规律，视觉上不太容易影响观感。频域上，非均匀采样的函数复制系列的间距也是随机的。

### 自适应采样

如果我们可以找出信号频率高于奈氏准则的部分，并在那些局部增加采样数，就可以在全局采样数增加不大的情况下采样到更多的信息。然而找到需要超采样的部分并不容易，因为原函数在采样点之间的行为是无法预测的。另外，高频的部分并不需要表示，比如 mipmap。

### 前滤波

通过滤波（即模糊化）可以直接限制原函数的带宽，滤去过高频率后的“原函数”
就很好采样了。虽然这个操作丢失了原函数的信息，但是重建瑕疵不会像走样那么丑。

在频域上移除高频等价于在时域上与 sinc 函数卷积。sinc 函数自变量的系数如果高于奈氏准则，就可以移除不能被采样的频率。使用有界定义域的 sinc 函数也能获得很好的结果。

## 1.5 采样理论在图像合成上的应用

以上的讨论都是在一元函数上进行的，图像无非就是映射到 radiance 值的二元函数：

$$
f(x, y) \rightarrow L
$$

这个函数处处可以求值，但是我们基本上无法进行前滤波。因此反走样的方法主要集中在提高采样率和非均匀采样。

对于运动场景或者带透镜的相机，有时需要把图像视作时间、透镜位置等参数结合的函数。更一般地，许多积分器使用统计方法来计算光线的 radiance，对条光线的多次计算可能有不同的结果，图像函数因此也可以包含积分器使用的参数。

## 1.6 渲染中的走样问题

几何结构是导致走样的常见原因之一。物体边界投影到成像平面时会变成一个阶梯函数，而阶梯函数的带宽没有上界。理想的采样滤波器应用到走样的采样上还会进一步导致重建结果来回振荡（吉布斯现象）。为反走样选择合适的重建滤波器涉及科学、艺术和个人品味等等因素。

过小的物体也会出现几何走样。如果物体小到落在两次相邻的采样之间，就会出现闪烁的问题。

走样的另一个原因是物体的纹理和材质。着色走样经常是因为纹理映射没有正确滤波，或者光滑表面的高光没有正确处理。如果对纹理和材质的采样频率不够高，也会导致走样。物体投射的硬阴影也是阶梯函数，相较于分辨图像上几何边缘的阶梯函数，阴影导致的阶梯函数更难被识别出来。

走样是永远无法避免的，我们能做的只有尽可能减小它对图像的影响。

## 1.7 像素是什么

关于像素有两个重要的概念：首先，组成图像的像素是图像函数的一系列点采样，图像函数在成像平面上表现为离散的点，而***像素没有面积***，像素拥有确定面积的模型会导致一系列错误想法（比如滤波器一定是方的或者图像缩放），像素是前文提到的采样点。

小方格模型一般出现在将整个视窗平分给每个采样点（像素）的过程中，此时每个小方格为各自对应的像素采样值做出贡献。但这并不代表像素就是小方格。

其次，图像的像素由离散的整点坐标表示，而 `Sampler` 生成的图像采样是连续的浮点坐标。它们之间的转换需要一个合适的映射。比较自然的想法是将小数映射到最近的整数，但这样的结果是对于一个整数区间 $[x_0, x_1]$，对应的小数区间 $[x_0 - 0.5, x_1 + 0.5)$ 在左端会有 0.5 的偏移，这个偏移很容易被忘记。因此我们将整数区间对应到右端更大一些的小数区间 $[x_0, x_1 + 1)$。公式是

$$
d = \lfloor c\rfloor\\
c = d + \frac{1}{2}
$$

这样的代码也更简洁。


# 2 采样接口

采样器的任务是在 $[0, 1)^n$ 中生成一系列样本，一个样本向量对应一个图像样本，而它的维数取决于生成样本时使用的光线传播算法（比如蒙特卡洛光线传播算法）。

由于采样值严格小于 1，可以预先定义一个常量作为上界，pbrt 使用的上界分别逼近 IEEE754 单精度和双精度的阶尾数范围（即 23 位和 52 位，不包含规格化的 1）。代码中可以写为

```cpp
// Using double
static constexpr double one_minus_epsilon = 0x1.fffffffffffffp0 / 2;
// Using float
static constexpr float one_minus_epsilon = 0x1.fffffep0 / 2;
```

C++14 似乎不支持在指数上写负数，就用除以二来表示了，计算结果应该是一样的。

最简单的采样器可能是一个均匀分布，由于许多光线最后很可能对像素没有贡献，这种方法需要很多次采样。使用更精巧的采样方法一般不会有太多时间开销，但是对成像质量会有很大提升，因为追踪光线并计算它对 radiance 的贡献一般比生成一个采样更费时。

对一个采样向量有如下假定：

- 前五个分量一般是所有相机实现都要用到的，其中前两个用于在当前像素分到的（方形）面积里指定位置，第三个是时间参数，后两个是在镜片上的位置（用于景深）。
- 一些采样算法比较侧重于优化采样向量的部分分量。我们假设靠前的分量值是分布最好的。

注意采样可能不是一次性生成，而是渐进地生成或更新的。

## 2.1 采样模式评估：差异值

<!-- TODO 7.2.1 跳过 -->

## 2.2 基础的采样器接口

所有的采样器实现都应该在构造函数里指定结果图像中每个像素的采样数。在一些罕见的情况下，整个观察区域只会对应一个像素。由于一个像素可能有数十亿个采样，我们使用一个 64 位整型（`int_64t`）来存储它。

当我们打算处理一个像素时，首先调用 `StartPixel()` 函数，传入这个像素在图像中的位置。这个数据会被某些采样算法用来优化采样的整体分布。

`Get1D()` 函数被用来获取*当前*采样向量下一个维度的值，而 `Get2D()` 是获取下两个。同时使用两个维度值可以被某些采样器用来优化结果（可能就是写着方便？）。没有一次性获取更多值得函数，因为一般没有这样的算法，如有需要可以直接构造出来。切换到下一个采样向量需要调用 `StartNextSample()`。

两个获取采样向量分量的函数工作方式类似生成器，注意保持调用它们的次序和次数。

为了方便，采样器实现了初始化一个相机样本的函数，用来初始化时间、像素相对位置等等总要用到的信息。

有些渲染算法使用它们采样的部分维度的采样值组织成的数组。大多数采样算法通过统计数组中所有的采样值和像素中所有的采样，可以生成高质量的采样数组，一般优于一系列独立的算法。

<!-- TODO 采样数组这块没看懂 -->

采样数组需要在渲染开始前使用 `Request[12]DArray()` 初始化好。比如在一个有两个面积光的场景里，积分器追踪射向第一个光源的四条阴影光线和第二个光源的八条，它需要对每个图像采样各获取一个二维采样数组（二维是因为要描述光源表面）。13.7 节会展示使用这种采样配合蒙特卡洛方法可以获得在光线传输积分的某些维度上更密集的采样。

当数组大小特定时，多数采样器可以有更好的生成结果，比如 `ZeroTwoSequenceSampler` 的样本在数量为 2 的幂次时分布更好。`RoundCount()` 函数就是用来实现这个功能的，它接收调用者想要的采样数量，采样器可以在此基础上返回优化过的采样数，比如向上取到 2 的幂。返回值就是实际会获取到的采样数。在采样器基类里这个函数将参数原样返回。

`Get[12]DArray()` 函数被用来获取之前请求的对应维数的采样数组，返回值是指向该数组的指针。基本上就是重复多次的 `Get[12]D()`，但是要接收采样数量用于验证。

当对一个采样的工作结束后，积分器需要调用 `StartNextSample()` 来告知积分器后续的 `Getxxx()` 要从当前像素下一个采样的第一维开始。类似迭代器的 `next()` 函数，这个函数会一直返回真，直到没有下一个采样可以生成。

采样器维护了采样的许多状态，不是一个可以共享的资源，因此需要 `Clone()` 函数来生成一个初始化好的采样器实例给新的渲染线程使用。函数接收一个随机数种子（采样算法不一定用到）来保证实例的行为*完全随机*（避免一致的瑕疵等等）。

有些光线传播算法会跳过部分采样，因此需要 `SetSampleNumber()` 函数来实现随机访问。

## 2.3 采样器实现

一些基础功能的实现，主要是流程。

注意虚函数在子类重写时需要显式调用。

调用 `Request[12]DArray()` 时，采样数和开辟出的空采样分别被放入对应的存储结构（这里是 `std::vector`）。注意这是一个二维的结构。

<!-- NOTE 此处的内存分配对性能有多大影响？ -->

获取之前请求的采样数组会得到一个指针，指向单个采样，可以通过自增来获取下一个值。函数需要更新采样数组的偏移。不同维数的偏移是分开记录的。

## 2.4 像素采样器

生成采样向量可以是渐进式的，也可以一次就生成单个像素的所有采样向量。`PixelSampler` 子类用来实现一次性生成的各种采样器。

渲染算法使用的采样向量维数（通过 `Get[12]D()` 消耗的数据）是无法事先确定的，所以像素采样器使用了最大数量。如果这些也被消耗完了，采样器就会返回均匀分布的随机值。

采样向量的存储是维数为主序，采样数次之，这样每个维度内连续的内存分布更便于生成。

## 2.5 全局采样器

全局采样器在整张图片上分布采样点。这个逻辑和之前的采样器接口有一点不匹配。

但是现在的采样器设计有利于并行渲染整张图片。所以，这些采样器的生成方式需要经过全局采样器这一层实现一点调整。

具体通过两个新的纯虚函数来调整。一个函数将当前像素和当前采样下标转换为全局的采样向量下标；另一个函数接收全局的采样向量下标和维数，返回相对于当前像素的值（其中像素位置需要处理成像素相对位置）。

其他要做的事情大概就是使用这两个函数把全局采样算法生成的采样向量填到像素采样器的采样数组里面。

## 3 分层采样

分层不止局限在二维图像上，也可以在时间、镜片上，一般的想法是在需要分层的维度独立采样，然后随机取各维度的采样值组合成一个采样向量。每个维度的 strata 当然要一样多。

分层可以配合 jittering，以保持随机性。

这里附带介绍了 Latin hypercube sampling（LHS），在任意维数立方体的对角线上生成任意多个采样点，然后将这些点的坐标在各自维度里 shuffle。主要是为了解决像素采样数不能被完整开方的问题，如果传入本身就是平方根可能容易做一些，但是调整采样数的粒度就变大了。


## 4 Halton 采样



